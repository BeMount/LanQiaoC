/*

问题描述
　　有n个人围成一圈，顺序排号（编号为1到n）。
 从第1个人开始报数(从1到3报数)，凡报到3的人退出圈子。
 从下一个人开始继续报数，直到剩下最后一个人，游戏结束。
　　问最后留下的是原来第几号的那位。
　　举个例子，8个人围成一圈：
　　1 2 3 4 5 6 7 8
　　第1次报数之后，3退出，剩下：
　　1 2 4 5 6 7 8 （现在从4开始报数）
　　第2次报数之后，6退出，剩下：
　　1 2 4 5 7 8 （现在从7开始报数）
　　第3次报数之后，1退出，剩下：
　　2 4 5 7 8 （现在从2开始报数）
　　第4次报数之后，5退出，剩下：
　　2 4 7 8 （现在从7开始报数）
　　第5次报数之后，2退出，剩下：
　　4 7 8 （现在从4开始报数）
　　第6次报数之后，8退出，剩下：
　　4 7 （现在从4开始报数）
　　最后一次报数之后，4退出，剩下：
　　7.
　　所以，最后留下来的人编号是7。
输入格式
　　一个正整数n，(1<n<10000)
输出格式
　　一个正整数，最后留下来的那个人的编号。
样例输入
8
样例输出
7
数据规模和约定
　　对于100%的数据，1<n<10000。

*/ 
#include <stdio.h>  
int q_number(int*,int);
void fuzhi(int*,int);
 
int main(void)  
{   
 int n;
 scanf("%d",&n);
 int a[n];
 fuzhi(a,n);
 printf("%d\n",q_number(a,n));  
 return 0;  
}

void fuzhi(int*a,int n)
{
 int i;
 for(i=0;i<n;i++)
 {
  a[i]=i+1;
 }
} 

int q_number(int *a,int n)
{
 int k=n,xb=0,t=0;
 while(k>0)
 {
 int i,xb=0;
 for(i=0;i<k;i++)
 {
  t++;
  if(t%3)
  {
   a[xb++]=a[i];
  }
 } 
 k=xb;
 }
 return a[0];
}   
