/*

问题描述

小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。

小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。

你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。

本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。
输入格式

两个正整数，表示每种包装中糖的颗数(都不多于1000)
输出格式

一个正整数，表示最大不能买到的糖数
样例输入1
4 7
样例输出1
17
样例输入2
3 5
样例输出2
7
 
*/
/*

问题描述
　　有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：

　　每个小朋友都把自己的糖果分一半给左手边的孩子。

　　一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。

　　反复进行这个游戏，直到所有小朋友的糖果数都相同为止。

　　你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。
输入格式
　　程序首先读入一个整数N(2<N<100)，表示小朋友的人数。
　　接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）
输出格式
　　要求程序输出一个整数，表示老师需要补发的糖果数。
样例输入
3
2 2 4
样例输出
4
 
*/ 
#include <stdio.h>
void input(int n,int *a);
int panduan(int,int*);
void q_dgs(int n,int *a,int *p_dg);

int main(void) 
{
	int n;
	scanf("%d",&n);
	int a[n];
	input(n,a);
	int dgs=0;
	q_dgs(n,a,&dgs);
	printf("%d\n",dgs);
	return 0;
}


void input(int n,int *a)
{
 while(n--)
 {
  scanf("%d",a++);
 }
}

void q_dgs(int n,int *a,int *p_dgs)
{
	while(1)
	{
	 if(panduan(n,a)==1)
	 {
	  break;
	 }
	 int i;
	 for(i=0;i<n;i++)
	 {
	   if(a[i]%2!=0)
	   {
	    ++*p_dgs;
		a[i]+=1; 
	   }
	   a[i]/=2;
	 }
	 int k;
	 int t=a[0];
	 for(k=0;k<n-1;k++)
	 {
	  a[k]=a[k]+a[k+1];
	 }
	 a[n-1]+=t;
	}
}

int panduan(int n,int*a)
{
 int i;
 for(i=0;i<n-1;i++)
 {
  if(a[i]!=a[i+1])
  {
   return 0;
  } 
 }
 return 1;
} 
